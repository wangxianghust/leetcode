#剑指offer
--------

## 第二章
#### 二维数组查找问题
* 选择右上角的节点作为参考点，每次和target比较，会删除一行或者一列
* 主要是选择合适的参考点，利用夹逼法进行范围的缩小

#### 重建二叉树
给定二叉树的前序和中序遍历，求构建完整的二叉树

前序遍历确定根节点，再拿到中序遍历里面，确定左右子树； 对以上程序递归调用。

#### 位运算
求一个数转化为二进制，其中1的个数

观察得到，数n-1,会将末尾的1变为0，后面被取反，如 10100 减1 10011，这两个数相与，会得到一个计数，
统计这种操作进行了多少次即可。

拓展：求m,n二进制数中的不同的个数，方法，先异或，再统计1的个数
#### 链表
* 有时候需要先遍历得到个数再处理
* 提前询问是否可以修改链表的结构
* 提前考虑并处理特殊情况，如链表为空等
* 删除的时候，有没有可能是head,所以很有一个dummy指针的必要
* 反向遍历链表是，可以和stack结合

## 第三章

#### 数值的整数次方
模拟pow的预算，double pow(double base, int exp), 要考虑base=0, exp<0的情况，同时exp<0的情况，指数的运算可以使用优化，分exp奇数偶数计算一半即可。
位运算的使用：exp << 1, exp & 0x1(判断奇偶性)

```
	class Solution {
	public:
	double myPow(double x, int n){
		if(n == 0) return 1;	
        if(n < 0 && n != INT_MIN){        
            n = -n;           
            x = 1/x;            
        }      
        	return n & 0x1 ? x*myPow(x*x, n>>1) : myPow(x*x, n>>1); 
        }
	};
```

#### 打印1到最大的n位数
重点是要考虑到大数的情况，LL也保存不下的那种 

1. 用string保存，模拟加法，同时注意0123这样的要去除前导0
* 回溯法，即求n个数字的全排列

#### O(1)时间删除链表的一个节点
给定的输入时head ptr 和 delete_node ptr

既然给的是ptr,我们可以直接把delete_node->next 的val 赋值给delete_node,再进行删除。
同时需要考虑是尾节点的情况，这时候必须要全部遍历一遍了。

#### 求链表倒数k个节点
双指针

求链表的中间节点：slow和fast指针，fast是slow的两倍，fast到尾巴时候，slow到中间

判断是否有环：一个走一步，一个走两步，如果有环的话，肯定会相遇



